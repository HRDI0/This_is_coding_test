# 무지의 먹방 라이브

# 회전판에 먹어야 할 n개의 음식이 있습니다. 각 음식에는 1부터 n까지의 번호가 붙어 있으며,
# 각 음식을 섭취하는데 일정 시간이 소요됩니다. 무지는 다음과 같은 방법으로 음식을 섭취합니다.
# 1. 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓습니다.
# 2. 마지막 번호의 음식을 1초 동안 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 옵니다.
# 3. 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 먹습니다. 
# 4. 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정합니다.

# 먹방을 시작한 지 k초 후에 네트워크 장애로 방송이 잠시 중단되었습니다. 
# 무지는 방송이 다시 시작되면 몇번 음식부터 섭취해야 하는지 알고자 합니다.

# 각 음식을 모두 먹는 데 필요한 시간이 담겨 있는 배열 good_times, 네트워크 장ㅇ애가 발생한 시간 k초가 매개변수로 주어질 때,
# 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 함수를 완성하세요.

# 제한 사항
# food_times 는 각 음식을 모두 먹는 데 필요한 시간이 음식의 번호 순서대로 들어 잇는 배열입니다.
# k는 방송이 중단된 시간을 나타냅니다.
# 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 됩니다.

# 정확성 테스트 제한 사항
# food_times 의 길이는 1 이상 2,000 이하이다.
# food_times 의 원소는 1 이상 1,000 이하의 자연수이다.
# k는 1 이상 2,000,000 이하의 자연수이다.


# 효율성 테스트 제한 사항
# food_times 의 길이는 1 이상 200,000 이하이다.
# food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다.
# k는 1 이상 2 x 10^13 이하의 자연수이다.
# 입출력 예
# food_times	k	result
# [3, 1, 2]	5	1
# 입출력 예 설명
# 입출력 예 #1

# 0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
# 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
# 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
# 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
# 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
# 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.
import heapq
from sys import stdin
input = stdin.readline

food_times = list(map(int, input().split()))
k = int(input())

def solution(food_times, k):
    q = []
    size = len(food_times)
    alltime = 0
    for i in range(size):
        heapq.heappush(q,(food_times[i],i+1))
        alltime += food_times[i]

    if alltime <= k:
        return -1
    sum_t = 0
    pre_ft =0
    while sum_t + ((q[0][0] - pre_ft)*size) <= k:
        foodtime = heapq.heappop(q)[0]
        sum_t += (foodtime - pre_ft) * size
        size -=1
        pre_ft = foodtime
    result = sorted(q,key=lambda x:x[1])
    return result[((k - sum_t) %size)][1]

            
print(solution(food_times, k))